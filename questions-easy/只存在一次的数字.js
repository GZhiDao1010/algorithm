// 只存在一次的数字
/* 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
输入: [2,2,1]
输出: 1
*/

const nums = [2,3,1,2,3,1,8]

/*
异或解法：异或运算满足交换律，a^b^a=a^a^b=b,因此ans相当于nums[0]^nums[1]^nums[2]^nums[3]^nums[4]..... 
然后再根据交换律把相等的合并到一块儿进行异或（结果为0），然后再与只出现过一次的元素进行异或，这样最后的结果就是，
只出现过一次的元素（0^任意值=任意值）
异或是机器码运算，相同为0不同为1，不管数字先后，只要两个数字相同对应的二进制都会被异或为00000000，最后剩下的就是所要找的值

有一个数组，含有值：12，7，12。并含有一个变量甲，其值为0。（先不要纠结为何要这么定义，这是为了了解按位异或操作符的神奇性质）
——————第一次：

12：0 0 0 0 1 1 0 0 

甲：0 0 0 0 0 0 0 0

异或

甲：0 0 0 0 1 1 0 0（值为12）

——————第二次

 7：0 0 0 0 0 1 1 1

甲：0 0 0 0 1 1 0 0

异或

甲：0 0 0 0 1 0 1 1（值为11）

——————第三次

12：0 0 0 0 1 1 0 0

甲：0 0 0 0 1 0 1 1

异或

甲：0 0 0 0 0 1 1 1（值为7）

——————遍历结束

返回值：甲。甲值为 7 ，数组中唯一元素为 7。

通过观察，和结合按位异或操作符的性质我们可以发现一个按位异或操作的性质：一个值和0进行按位异或操作所得为该值，
相同的两个值进行异或操作，所得为0（甲 按位异或 0 得 甲，甲 按位异或 甲 得 0）。

根据这个性质，由于每个重复元素重复两次，故他们在遍历后将相互抵消，而唯一元素只出现一次，故将得到保留

*/


const singleNumber = (nums)=>{
    let ans = 0;
    for(const num of nums){
        ans ^=num
    }
    return ans
}
console.log('singleNumber(nums) :>> ', singleNumber(nums));